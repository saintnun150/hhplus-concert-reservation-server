# 서비스 규모 확장에 따른 MSA 분리와 트랜잭션 관리 설계

## 서론
콘서트 예약 서비스의 경우 모놀리틱 아키텍쳐로 한 애플리케이션에 사용자, 콘서트, 결제, 대기열 등 여러 도메인을 핸들링하고 있다.
서비스 규모가 확장됐다는 가정하에 MSA로 분리하고 트랜잭션 관리를 어떻게 할 것인지에 대해 조사했다.

<br/>

## MSA 전환의 장단점
- 모놀리틱 아키텍쳐에서 마이크로 서비스 아키텍쳐로 전환하게 될 경우 다음과 같은 장단점이 있다.
  - 장점
    - 도메인 분리로 인한 특정 도메인에 대한 유지보수 및 유연한 배포와 서비스 확장 가능
    - 장애 발생시 전체 서비스에 미치는 영향도 최소화로 서비스 안정성 향상
    - 각 서비스별로 할당된 인프라 자원에 대해 최적의 활용 가능
  - 단점
    - 서비스 간 통신이 필요하므로 네트워크 지연이 발생할 수 있음
    - 운영 관점에서는 모놀리틱 아키텍쳐보다 복잡성이 높을 수 있다.
    - 일부 서비스들은 공통적으로 사용하는 데이터가 있을 수 있으며 이에 대한 데이터 일관성 유지에 대한 문제가 발생할 수 있다.
    - 여러 서비스가 하나의 기능으로 동작할 때 트랜잭션에 대한 범위 설정 및 관리에 어려움이 발생한다.

<br/>

## 트랜잭션 범위 분석 및 애플리케이션 이벤트를 통한 도메인간 기능 분리

### 결제 기능에 대한 트랜잭션 범위 분석

현재 유즈케이스에서 결제를 진행할 때 다음과 같은 절차로 진행되고 있다.
```java
@Transactional
public void 결제진행() {
  // 1. 예약 정보 조회
  // 2. 좌석 확인 및 유효성 검사
  // 3. 사용자 조회
  // 4. 포인트 차감
  // 5. 예약 상태 변경
  // 6. 결제 생성
  // 7. 대기열 토큰 만료처리
  // 8. (추가) 알림톡 등 외부 서비스 요청
}
```

결제 진행 시 예약, 콘서트 좌석, 사용자, 사용자 포인트, 결제, 대기열 각 도메인이 담당하는 기능이 하나의 트랜잭션으로 묶여있다.
해당 메서드가 완전한 책임을 가져야하는 부분은 3번, 4번, 6번이라고 생각한다.   
나머지는 ``책임이 아닌 영역``과 ``책임 수준이 낮다`` 구분과 그에 따른 ``예외발생시 처리방법``에 대해 차이가 있을 것 같아서 좀 더 분석했다.


- ``책임 수준 낮음``
  - 1, 2, 5번: 예약 상태 변경은 결제 생성이 성공된 후 이벤트 발행을 통해 결합도를 낮춰도 된다고 생각한다.    
    AS-IS: 결제 진행 메서드 안에서 콘서트 예약과 좌석에 대한 조회 및 유효성 검사가 발생함   
    TO-BE: 결제 진행 메서드 호출 전에 콘서트 예약과 좌석에 대한 유효성이 통과된 상태에서만 결제 진행을 호출가능하도록 설계 => 결제 완료 후 해당 도메인 서비스로 상태 변경 이벤트 발송
    <br/>
    <br/>

  - 3번: 조금 억지스러울 수도 있지만 결제 생성까지 정상적으로 완료되었을 때 포인트를 차감시킬 수도 있다고 생각했다.    
    하지만 조금만 더 생각해보면 ``포인트 차감에 실패했을 때 결제처리가 된 부분이 반드시 롤백``이 되어야한다.    
    따라서 분리하는 것이 더 비효율적이기 때문에 결제 진행의 책임으로 가져가는게 맞다고 생각한다.
    <br/>
    <br/>

  ``예약 상태 변경 바운더리 안에서 재시도나 실패 이력을 생성하는 쪽으로 전개``되어야한다고 생각했다.   
  지금은 단순히 포인트 차감으로 구현되어있지만 실제로 금융거래가 발생할 경우 연관된 서비스는 훨씬 더 많을 수 있다.    
  전부 이전 상태로 보상트랜젝션이 발생해야한다면 그 비용이 훨씬 더 클 것이다.

- ``책임이 아님``

  - 7번: 대기열 토큰 만료처리는 결제 진행과는 관련이 없기에 결제 트랜젝션에 포함될 필요가 없다. 이미 결제 성공이 됐다는 것은 해당 사용자가 대기열 토큰에 대해 사용을 완료했다는 것으로 봐도 무방하다. 결론적으로 대기열 토큰 만료처리에서 문제가 생겼다고 해서 결제 진행이 실패해야하는 것은 아니다.    
    다만 결제가 완료 시점에 토큰에 대한 유효성을 체크하도록 세부적으로 구현하는 것을 생각해볼 수 있다. 이 경우에는 차라리 결제 진행 메서드에 토큰 검증에 대한 책임을 둬 결제가 진행되지 못하도록 처리하는게 더 합리적인 방향이라고 생각한다.
    <br/>
    <br/>

  - 8번: 만약에 결제 완료시 외부 앎림 서비스를 호출하는 기능이 추가된다고 생각해보자. 외부 알림 서비스 호출에 실패하거나 외부 서비스 장애가 발생한다고 해서 결제 진행이 취소되야하는 것은 아니다.    
    기존 결제 진행이 완료되었다면 알림 서비스 호출에 실패하더라도 결제 진행은 성공적으로 완료된 것으로 간주해야하고, 실패에 대한 이력만 저장하여 재발송 등 해당 바운더리 안에서 처리되어야 할 것이다.

<br/>

### 애플리케이션 이벤트를 통한 도메인간 기능 분리
위에서 결제 진행 트랜젝션에서 관심사를 분리해야할 부분을 정리했다.    
이벤트 발행/구독에 대한 장단점은 다음과 같다.

- 장점
  - 특정 서비스에서 DI를 제거하여 결합도를 낮출 수 있다.
  - 해당 비즈니스 로직에는 직접 관련성있는 로직만 남게 되므로 응집도가 높아진다.
  - 필요한 이벤트를 발행하고 구독하는 리스너를 추가하기 쉬워 유연성이 증대된다.
  - 기존 발행 주체의 트랜잭션 시점에 따라 이벤트 처리시점을 유연하게 선택할 수 있다.
- 단점
  - 여러 이벤트가 발생한다면 이벤트 처리에 대한 순서 보장이 어려울 수 있다.
  - 디버깅 및 테스트가 어려울 수 있다.
  - 이벤트 수신 측에서 예외 발생시 기존 트랜잭션에 속해있지 않다면 예외 처리 등 별도 보상로직이 필요하다.
  - 이벤트 수신 측에서 동기 처리가 필요하다면 이벤트 발행 측에서 완료 대기시간이 길어질 수 있으므로 성능 이슈가 생길 수 있다.


아래는 대기열 토큰 만료처리에 대한 부분을 애플리케이션 이벤트를 통해 분리 구현했다.

```java

// ApplicationEventPublisher 구현체 생성
@Component
@RequiredArgsConstructor
public class PaymentEventPublisherImpl implements PaymentEventPublisher {
  private final ApplicationEventPublisher eventPublisher;

  @Override
  public void publish(Object event) {
    eventPublisher.publishEvent(event);
  }
}

// paymentFacade

@Transactional
public void payment() {
  ... 생략
  // AS-IS
  waitingQueueService.expireQueueToken(new WaitingQueueCommand.ExpireToken(token, paymentTime));
  // TO-BE
  // 이벤트 발행
  paymentEventPublisher.publish(WaitingQueueEvent.ExpireTokenEvent.of(token));
}

@Slf4j
@Component
@RequiredArgsConstructor
public class WaitingQueueEventListener {
  private final WaitingQueueService waitingQueueService;

  // 이벤트 구독
  @Async
  @TransactionalEventListener(phase = AFTER_COMMIT)
  public void onExpiredToken(WaitingQueueEvent.ExpireTokenEvent event) {
    // 결제 진행 트랜잭션이 완료된 후 대기열 토큰 만료 처리됨
    WaitingQueueCommand.ExpireToken command = new WaitingQueueCommand.ExpireToken(event.getToken(), event.getTimestamp());
    waitingQueueService.expireQueueToken(command);
  }
}

```

<br/>

## 트랜잭션 관리의 문제점과 해결방안
이렇게 도메인간 기능을 분리하게 될 경우 각 도메인 서비스는 각자 다른 인프라를 이용하기 때문에 트랜잭션의 원자성과 일관성을 보장하기 어렵다.
따라서 분산 트랜잭션 환경에서 이를 보장하기 위해 2PC(2 Phase Commit), SAGA 패턴을 사용할 수 있다.


### 2PC(2 Phase Commit)
2PC 패턴은 **Coordinator**(조정자)와 **Participants**(참여자)가 있다.
Coordinator는 트랜잭션 커밋에 대해 준비를 요청하면 Participants는 준비가 되었는지에 대한 응답을 보내고, 모든 참여자가 준비가 되었을 때 트랜잭션을 커밋한다.
만약 참여자 중 하나라도 준비가 안되었다면 트랜잭션을 롤백한다.

#### 1. **Prepare Phase (준비 단계)**
- 코디네이터는 트랜잭션을 시작하고 각 참여자에게 트랜잭션을 준비하도록 요청
- 각 참여자는 담당 작업을 완료하고 커밋 준비가 되었는지 `YES` 또는 `NO`로 응답

#### 2. **Commit Phase (커밋 단계)**
- 코디네이터는 모든 참여자가 `YES` 응답을 보냈을 경우에, 참여자에게 트랜잭션을 커밋하도록 요청한다. 커밋이 완료되면 코디네이터에게 성공 응답을 보낸다.
- 코디네이터가 `NO` 응답을 받은 경우 코디네이터는 참여자에게 트랜잭션을 롤백하도록 요청한다. 각 참여자는 이를 수신하고 트랜잭션을 롤백한다.

#### 장단점
- 장점
  - 모든 트랜젝션의 일관성 보장
    - 모든 참여자가 커밋 준비를 완료할 때까지 코디네이터는 트랜잭션을 보류하고, 트랜잭션이 커밋되기 전에 각 참여자가 `YES` 또는 `NO` 응답을 보내야 하므로 데이터 일관성을 보장할 수 있다.
    - 트랜잭션의 커밋이 실패하면 롤백을 요청하고 수행하여 데이터 일관성을 유지할 수 있다.

- 단점
  - 성능 저하: 모든 참여자가 커밋 준비를 완료할 때까지 코디네이터는 트랜잭션을 보류하며 모든 참여자의 응답에 대해 대기가 길어질 수 있다.
  - 단일 장애점: 모든 트랜잭션에 대한 요청은 코디네이터가 제어하기 때문에 만약에 코디네이터에 문제가 발생하면 전체 장애로 번질 수 있다.
  - 데드락 발생 가능성: 참여자들이 트랜잭션 작업시에 lock을 걸게되므로 다른 트랜잭션들이 대기하게 되거나 꼬이면 데드락이 발생할 수 있다.

### SAGA 패턴
SAGA 패턴의 경우 분산된 각 서비스들이 각자의 트랜젝션을 독립적으로 처리한다. 이 패턴에서는 각 트랜잭션의 작업이 성공할 경우 다음 트랜잭션이 실행되도록 한다.   
중간에 실패할 경우 보상 트랜잭션을 정의해 이전 작업에 대해 롤백을 진행하여 ``최종적으로 데이터 일관성 및 원자성``을 보장한다.

#### 1. **각각의 서비스가 수행하는 개별 트랜잭션 STEP**
- 성공하면 다음 단계로 진행.

#### 2. **보상 트랜잭션**
- 특정 트랜잭션이 실패할 경우 이전 단계들에 대해 정의된 보상 트랜잭션을 역순으로 실행하여 복구.

#### 방식
- 조정자(Orchestrator): Orchestrator라는 중앙에서 조정자가 존재하며 각 서비스는 Orchestrator에게 실행할 트랜잭션과 실패시 보상트랜잭션을 정의하며, 조정자는 각 서비스로 트랜잭션을 실행하고 실패시 보상트랜잭션을 실행한다.
- 이벤트-기반(Choreography): 각 서비스에서 트랜젝션이 완료되면 메시지 브로커에 이벤트를 발행하며 다음 실행되어야 하는 서비스는 해당 이벤트를 수신하여 다음 트랜잭션을 실행한다.

#### 장단점
- 장점
  - 확장성 및 유연성: 각 서비스가 트랜잭션을 관리하는 주체가 되므로 비교적 유연하게 확장 가능하다.
  - 각 단계가 성공해야 다음단계로 진행되므로 순서 제어가 용이
  - 특정 부분에서 실패하여 보상 트랜잭션 발생시 해당 트랜잭션 사이만 확인하면 되므로 비교적 관리 범위가 적다.

- 단점
  - 복잡성: 각 서비스 별 보상 트랜잭션에 대해 정의해야하고 이에 대한 관리가 필요하다.
  - 데이터 일관성 문제: 문제가 발생했을 경우 모든 보상 트랜잭션이 완료되기 전까지는 데이터 일관성을 보장할 수 없다.
    - 만약에 성공/실패에 따른 다음 트랜잭션에 대한 작업이 유실될 경우 데이터 일관성 문제가 발생할 수 있다.


### 트랜잭션 아웃박스 패턴(Transaction Outbox Pattern)
SAGA 패턴은 기존의 2PC 패턴에 비해 개선된 방법이지만 앞서 말한 트랜잭션 이벤트 유실로 인한 데이터 일관성 문제가 발생할 수 있다.
트랜잭션 아웃박스 패턴은 ``트랜잭션의 원자성 성질``을 이용해 데이터 처리 및 이벤트를 발행에 대한 부분을 ``하나의 트랜잭션에서 처리``해 데이터 처리나 이벤트 발행 실패시 불일치를 방지한다.
즉, 트랜잭션이 커밋될 경우 데이터와 이벤트가 항상 일관성을 유지할 수 있다.

#### 원리
##### 1. 아웃박스 테이블 추가

각 서비스는 아웃박스 테이블을 통해 트랜잭션 내에서 데이터와 함께 이벤트를 저장한다.
즉 데이터와 이벤트가 같은 트랜잭션으로 관리되고, 이로 인해 트랜잭션이 커밋되면 데이터와 이벤트는 항상 일치한다.

##### 2. 이벤트 발행 프로세스
트랜잭션이 커밋된 후 메시지 브로커가 아웃박스 테이블을 확인하여 커밋된 이벤트를 다음에 진행할 서비스로 발행한다.
성공적으로 발행된 이벤트는 아웃박스 테이블에서 삭제또는 상태를 변경한다.    
만약에 다음 서비스로 이벤트 발행이 실패할 경우 아웃박스 테이블에서 해당 이벤트를 다시 발행하는 형태로 재시도 로직이 가능하다.


#### 장단점

- 장점
  - 트랜잭션의 원자성을 보장하여 저장된 데이터 처리 및 이벤트 발행이 항상 일관성을 유지할 수 있다.
  - 아웃박스 테이블에 저장된 정보를 통해 장애 복구 및 재시도 로직을 수행하여 대응할 수 있다.

- 단점
  - 각 서비스별로 아웃박스 테이블을 추가해야하므로 관리포인트가 증가한다.
  - 아웃박스 테이블과 메시지 브로커 간의 연결점이 발생하므로 서비스 복잡도가 높아진다.

<br/>

## 결론

이번 챕터를 통해 MSA 전환에 따른 트랜잭션 관리, 서비스 간 트랜잭션 한계와 해결 방안 등을 깊이 있게 공부할 수 있었다.  
이전에는 서비스가 작은 단위로 나뉘면 개발 생산성과 유지보수 측면에서 MSA 전환이 무조건 유리하다고 생각했지만, 실제로는 트랜잭션 관리, 데이터 일관성, 서비스 간 통신 등 여러 문제가 발생할 수 있음을 알게 되었다.  
특히 서비스 규모가 크지 않거나 단순한 경우 MSA 전환이 오히려 복잡성을 높일 수 있으며, MSA로 전환하더라도 단계적으로 접근해야 함을 이해하게 되었다.